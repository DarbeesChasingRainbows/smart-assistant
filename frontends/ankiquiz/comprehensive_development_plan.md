# Comprehensive Development Plan - AnkiQuiz Enhancement

## Executive Summary

Transform AnkiQuiz from a basic flashcard system into a comprehensive learning platform with advanced features including:
- Complex medical scenario support with multi-part questions
- Cross-reference system similar to Obsidian
- Glossary integration per card
- Normalized database schema with proper relationships
- Enhanced domain model supporting rich content

## Current Architecture Analysis

### ‚úÖ What We Have
- **Domain Layer**: Clean DDD implementation with `Flashcard`, `SchedulingEngine`, `QuizGenerator`
- **Infrastructure**: Dapper + Npgsql for high-performance data access
- **Architecture**: Proper Hexagonal/Clean Architecture with dependency inversion
- **Content**: 168+ organized flashcard decks with pronunciation guides and glossaries

### ‚ùå What We Need
- Database schema and migrations
- Enhanced domain model for complex scenarios
- Cross-reference system
- Glossary integration
- Import/export functionality

## Phase 1: Database Schema Design & Migration System

### 1.1 Create Database Schema

**Priority**: Critical
**Timeline**: Week 1

Create normalized PostgreSQL schema.
**Note**: We will use **UUIDv7** generated in C# for primary keys to ensure time-ordered sorting, rather than database-generated UUIDv4.

```sql
-- Core Tables
CREATE TABLE decks (
    id UUID PRIMARY KEY, -- UUIDv7 generated by App
    name VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(100),
    subcategory VARCHAR(100),
    difficulty_level VARCHAR(20) CHECK (difficulty_level IN ('beginner', 'intermediate', 'advanced', 'expert')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE glossary_terms (
    id UUID PRIMARY KEY, -- UUIDv7
    term VARCHAR(255) NOT NULL UNIQUE,
    pronunciation VARCHAR(255),
    definition TEXT NOT NULL,
    etymology TEXT,
    category VARCHAR(100),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE flashcards (
    id UUID PRIMARY KEY, -- UUIDv7
    deck_id UUID NOT NULL REFERENCES decks(id) ON DELETE CASCADE,
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    question_type VARCHAR(50) DEFAULT 'simple' CHECK (question_type IN ('simple', 'multiple_choice', 'scenario_based', 'multi_part')),
    metadata JSONB, -- For storing complex question data, options, etc.
    next_review_date TIMESTAMPTZ NOT NULL,
    interval_days INTEGER NOT NULL DEFAULT 1,
    repetitions INTEGER NOT NULL DEFAULT 0,
    ease_factor DECIMAL(3,2) NOT NULL DEFAULT 2.50,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Cross-Reference System (Obsidian-like)
CREATE TABLE cross_references (
    id UUID PRIMARY KEY, -- UUIDv7
    source_type VARCHAR(50) NOT NULL CHECK (source_type IN ('flashcard', 'deck', 'glossary_term')),
    source_id UUID NOT NULL,
    target_type VARCHAR(50) NOT NULL CHECK (target_type IN ('flashcard', 'deck', 'glossary_term')),
    target_id UUID NOT NULL,
    reference_type VARCHAR(50) DEFAULT 'related' CHECK (reference_type IN ('related', 'prerequisite', 'follows_from', 'contradicts', 'example_of')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(source_type, source_id, target_type, target_id, reference_type)
);

-- Glossary-Card Relationships
CREATE TABLE flashcard_glossary_terms (
    flashcard_id UUID NOT NULL REFERENCES flashcards(id) ON DELETE CASCADE,
    glossary_term_id UUID NOT NULL REFERENCES glossary_terms(id) ON DELETE CASCADE,
    relevance_score DECIMAL(3,2) DEFAULT 1.0, -- How relevant this term is to the card
    PRIMARY KEY (flashcard_id, glossary_term_id)
);

-- Quiz Sessions (Enhanced)
CREATE TABLE quiz_sessions (
    id UUID PRIMARY KEY, -- UUIDv7
    user_id UUID, -- For future user system
    session_type VARCHAR(50) DEFAULT 'review',
    difficulty_level VARCHAR(20),
    total_cards INTEGER NOT NULL,
    completed_cards INTEGER DEFAULT 0,
    correct_answers INTEGER DEFAULT 0,
    session_data JSONB, -- Store session configuration, progress, etc.
    started_at TIMESTAMPTZ DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE quiz_session_cards (
    id UUID PRIMARY KEY, -- UUIDv7
    quiz_session_id UUID NOT NULL REFERENCES quiz_sessions(id) ON DELETE CASCADE,
    flashcard_id UUID NOT NULL REFERENCES flashcards(id),
    position INTEGER NOT NULL, -- Order in quiz
    user_answer TEXT,
    is_correct BOOLEAN,
    response_time_ms INTEGER,
    difficulty_rating VARCHAR(10) CHECK (difficulty_rating IN ('again', 'hard', 'good', 'easy')),
    answered_at TIMESTAMPTZ
);

-- Indexes for Performance
CREATE INDEX idx_flashcards_deck_id ON flashcards(deck_id);
CREATE INDEX idx_flashcards_next_review_date ON flashcards(next_review_date);
CREATE INDEX idx_cross_references_source ON cross_references(source_type, source_id);
CREATE INDEX idx_cross_references_target ON cross_references(target_type, target_id);
CREATE INDEX idx_glossary_terms_term ON glossary_terms(term);
CREATE INDEX idx_quiz_sessions_started_at ON quiz_sessions(started_at);
```

### 1.2 Migration System Implementation (DbUp)

**Files to Create**:
- `Retention.Infrastructure/Database/DbUpRunner.cs`
- `Retention.Infrastructure/Database/DatabaseInitializer.cs`

We will use **DbUp** (`dbup-postgresql`) as confirmed in the project TODOs.

```csharp
// Retention.Infrastructure/Database/DbUpRunner.cs
public class DbUpRunner
{
    private readonly string _connectionString;
    
    public DbUpRunner(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    public void RunMigrations()
    {
        EnsureDatabase.For.PostgresqlDatabase(_connectionString);
        
        var upgrader = DeployChanges.To
            .PostgresqlDatabase(_connectionString)
            .WithScriptsEmbeddedInAssembly(Assembly.GetExecutingAssembly())
            .LogToConsole()
            .Build();
            
        var result = upgrader.PerformUpgrade();
        
        if (!result.Successful)
        {
            throw new Exception("Database migration failed", result.Error);
        }
    }
}
```

## Phase 2: Enhanced Domain Model

### 2.1 Expand Domain Entities

**Priority**: High
**Timeline**: Week 2

**Files to Modify/Create**:
- `Retention.Domain/Entities/Deck.cs`
- `Retention.Domain/Entities/GlossaryTerm.cs`
- `Retention.Domain/Entities/CrossReference.cs`
- `Retention.Domain/ValueObjects/QuestionMetadata.cs`

```csharp
// Retention.Domain/Entities/Deck.cs
public class Deck : Entity<Guid>
{
    public string Name { get; private set; }
    public string Description { get; private set; }
    public string Category { get; private set; }
    public string Subcategory { get; private set; }
    public DifficultyLevel DifficultyLevel { get; private set; }
    public DateTime CreatedAt { get; private set; }
    public DateTime UpdatedAt { get; private set; }
    
    private readonly List<Flashcard> _flashcards = new();
    public IReadOnlyList<Flashcard> Flashcards => _flashcards.AsReadOnly();
    
    public void AddFlashcard(Flashcard flashcard)
    {
        _flashcards.Add(flashcard);
        UpdatedAt = DateTime.UtcNow;
    }
}

// Retention.Domain/Entities/GlossaryTerm.cs
public class GlossaryTerm : Entity<Guid>
{
    public string Term { get; private set; }
    public string Pronunciation { get; private set; }
    public string Definition { get; private set; }
    public string Etymology { get; private set; }
    public string Category { get; private set; }
    
    public GlossaryTerm(string term, string pronunciation, string definition, string etymology = null, string category = null)
    {
        Term = term ?? throw new ArgumentNullException(nameof(term));
        Pronunciation = pronunciation ?? throw new ArgumentNullException(nameof(pronunciation));
        Definition = definition ?? throw new ArgumentNullException(nameof(definition));
        Etymology = etymology;
        Category = category;
    }
}

// Retention.Domain/ValueObjects/QuestionMetadata.cs
public record QuestionMetadata
{
    public QuestionType Type { get; init; }
    public List<string> Options { get; init; } = new();
    public List<string> CorrectAnswers { get; init; } = new();
    public string Scenario { get; init; }
    public Dictionary<string, object> AdditionalData { get; init; } = new();
    
    public static QuestionMetadata Simple() => new() { Type = QuestionType.Simple };
    
    public static QuestionMetadata MultipleChoice(List<string> options, List<string> correctAnswers)
        => new() { Type = QuestionType.MultipleChoice, Options = options, CorrectAnswers = correctAnswers };
        
    public static QuestionMetadata ScenarioBased(string scenario, List<string> options, List<string> correctAnswers)
        => new() { Type = QuestionType.ScenarioBased, Scenario = scenario, Options = options, CorrectAnswers = correctAnswers };
}

public enum QuestionType
{
    Simple,
    MultipleChoice,
    ScenarioBased,
    MultiPart
}
```

### 2.2 Enhanced Flashcard Entity

```csharp
// Retention.Domain/Entities/Flashcard.cs (Enhanced)
public class Flashcard : Entity<Guid>
{
    public Guid DeckId { get; private set; }
    public string Question { get; private set; }
    public string Answer { get; private set; }
    public QuestionMetadata Metadata { get; private set; }
    public SchedulingData Scheduling { get; private set; }
    
    private readonly List<GlossaryTerm> _glossaryTerms = new();
    public IReadOnlyList<GlossaryTerm> GlossaryTerms => _glossaryTerms.AsReadOnly();
    
    private readonly List<CrossReference> _crossReferences = new();
    public IReadOnlyList<CrossReference> CrossReferences => _crossReferences.AsReadOnly();
    
    public void AddGlossaryTerm(GlossaryTerm term, decimal relevanceScore = 1.0m)
    {
        if (!_glossaryTerms.Contains(term))
        {
            _glossaryTerms.Add(term);
        }
    }
    
    public void AddCrossReference(CrossReference reference)
    {
        if (!_crossReferences.Contains(reference))
        {
            _crossReferences.Add(reference);
        }
    }
}
```

## Phase 3: Repository Pattern Enhancement

### 3.1 Enhanced Repository Interfaces

**Files to Create/Modify**:
- `Retention.Domain/Repositories/IDeckRepository.cs`
- `Retention.Domain/Repositories/IGlossaryRepository.cs`
- `Retention.Domain/Repositories/ICrossReferenceRepository.cs`

```csharp
// Retention.Domain/Repositories/IDeckRepository.cs
public interface IDeckRepository
{
    Task<Deck?> GetByIdAsync(Guid id);
    Task<IEnumerable<Deck>> GetByCategoryAsync(string category, string subcategory = null);
    Task<IEnumerable<Deck>> GetAllAsync();
    Task AddAsync(Deck deck);
    Task UpdateAsync(Deck deck);
    Task DeleteAsync(Guid id);
}

// Retention.Domain/Repositories/IGlossaryRepository.cs
public interface IGlossaryRepository
{
    Task<GlossaryTerm?> GetByIdAsync(Guid id);
    Task<GlossaryTerm?> GetByTermAsync(string term);
    Task<IEnumerable<GlossaryTerm>> SearchTermsAsync(string searchText);
    Task<IEnumerable<GlossaryTerm>> GetByCategoryAsync(string category);
    Task<IEnumerable<GlossaryTerm>> GetForFlashcardAsync(Guid flashcardId);
    Task AddAsync(GlossaryTerm term);
    Task UpdateAsync(GlossaryTerm term);
    Task DeleteAsync(Guid id);
}
```

### 3.2 Dapper Implementation

```csharp
// Retention.Infrastructure/Repositories/DeckRepository.cs
public class DeckRepository : IDeckRepository
{
    private readonly string _connectionString;
    
    public DeckRepository(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    public async Task<Deck?> GetByIdAsync(Guid id)
    {
        const string sql = @"
            SELECT d.*, f.* 
            FROM decks d
            LEFT JOIN flashcards f ON d.id = f.deck_id
            WHERE d.id = @Id";
            
        using var connection = new NpgsqlConnection(_connectionString);
        
        var deckDict = new Dictionary<Guid, Deck>();
        
        await connection.QueryAsync<DeckDto, FlashcardDto, Deck>(
            sql,
            (deckDto, flashcardDto) =>
            {
                if (!deckDict.TryGetValue(deckDto.Id, out var deck))
                {
                    deck = deckDto.ToDomain();
                    deckDict.Add(deck.Id, deck);
                }
                
                if (flashcardDto != null)
                {
                    deck.AddFlashcard(flashcardDto.ToDomain());
                }
                
                return deck;
            },
            new { Id = id },
            splitOn: "id");
            
        return deckDict.Values.FirstOrDefault();
    }
}
```

## Phase 4: Import System for Existing Decks

### 4.1 Deck Import Service

**Files to Create**:
- `Retention.Domain/Services/IDeckImportService.cs`
- `Retention.Infrastructure/Services/DeckImportService.cs`

```csharp
// Retention.Domain/Services/IDeckImportService.cs
public interface IDeckImportService
{
    Task<ImportResult> ImportDeckFromFileAsync(string filePath, Guid? deckId = null);
    Task<ImportResult> ImportGlossaryFromFileAsync(string filePath);
    Task<ImportResult> CreateCrossReferencesAsync();
}

// Retention.Infrastructure/Services/DeckImportService.cs
public class DeckImportService : IDeckImportService
{
    private readonly IDeckRepository _deckRepository;
    private readonly IFlashcardRepository _flashcardRepository;
    private readonly IGlossaryRepository _glossaryRepository;
    
    public async Task<ImportResult> ImportDeckFromFileAsync(string filePath, Guid? deckId = null)
    {
        var lines = await File.ReadAllLinesAsync(filePath);
        var fileName = Path.GetFileNameWithoutExtension(filePath);
        
        // Parse deck metadata from filename
        var deckInfo = ParseDeckInfo(fileName);
        
        var deck = new Deck(
            deckId ?? Guid.NewGuid(),
            deckInfo.Name,
            deckInfo.Description,
            deckInfo.Category,
            deckInfo.Subcategory,
            deckInfo.DifficultyLevel
        );
        
        // Parse flashcards from file content
        var flashcards = ParseFlashcards(lines, deck.Id);
        
        foreach (var flashcard in flashcards)
        {
            deck.AddFlashcard(flashcard);
        }
        
        await _deckRepository.AddAsync(deck);
        
        return new ImportResult
        {
            Success = true,
            ImportedDecks = 1,
            ImportedFlashcards = flashcards.Count,
            Messages = new[] { $"Successfully imported deck: {deck.Name}" }
        };
    }
    
    private List<Flashcard> ParseFlashcards(string[] lines, Guid deckId)
    {
        var flashcards = new List<Flashcard>();
        
        for (int i = 0; i < lines.Length; i += 2)
        {
            if (i + 1 < lines.Length && 
                !string.IsNullOrWhiteSpace(lines[i]) && 
                !lines[i].StartsWith("//"))
            {
                var question = lines[i].Trim();
                var answer = lines[i + 1].Trim();
                
                // Detect question type and parse metadata
                var metadata = DetectQuestionType(question, answer);
                
                var flashcard = new Flashcard(
                    Guid.NewGuid(),
                    deckId,
                    question,
                    answer,
                    metadata,
                    SchedulingData.New()
                );
                
                flashcards.Add(flashcard);
            }
        }
        
        return flashcards;
    }
}
```

## Phase 5: Cross-Reference System (Obsidian-like)

### 5.1 Cross-Reference Engine

```csharp
// Retention.Domain/Services/ICrossReferenceEngine.cs
public interface ICrossReferenceEngine
{
    Task<IEnumerable<CrossReference>> FindRelatedContentAsync(Guid entityId, string entityType);
    Task<IEnumerable<CrossReference>> FindPrerequisitesAsync(Guid flashcardId);
    Task<IEnumerable<CrossReference>> FindFollowUpContentAsync(Guid flashcardId);
    Task CreateAutomaticReferencesAsync();
}

// Retention.Infrastructure/Services/CrossReferenceEngine.cs
public class CrossReferenceEngine : ICrossReferenceEngine
{
    public async Task<IEnumerable<CrossReference>> FindRelatedContentAsync(Guid entityId, string entityType)
    {
        // Use semantic similarity, keyword matching, and category relationships
        // to find related content automatically
        
        const string sql = @"
            WITH entity_keywords AS (
                SELECT unnest(string_to_array(lower(question || ' ' || answer), ' ')) as keyword
                FROM flashcards 
                WHERE id = @EntityId
            ),
            related_cards AS (
                SELECT f.id, f.question, f.answer,
                       COUNT(ek.keyword) as keyword_matches
                FROM flashcards f
                CROSS JOIN entity_keywords ek
                WHERE f.id != @EntityId
                  AND (lower(f.question) LIKE '%' || ek.keyword || '%' 
                       OR lower(f.answer) LIKE '%' || ek.keyword || '%')
                GROUP BY f.id, f.question, f.answer
                HAVING COUNT(ek.keyword) >= 2
                ORDER BY keyword_matches DESC
                LIMIT 10
            )
            SELECT * FROM related_cards";
            
        // Implementation details...
    }
}
```

## Phase 6: API Enhancement

### 6.1 Enhanced API Controllers

**Files to Create/Modify**:
- `Retention.App/Controllers/DecksController.cs`
- `Retention.App/Controllers/GlossaryController.cs`
- `Retention.App/Controllers/CrossReferencesController.cs`

```csharp
// Retention.App/Controllers/DecksController.cs
[ApiController]
[Route("api/[controller]")]
public class DecksController : ControllerBase
{
    private readonly IDeckRepository _deckRepository;
    private readonly ICrossReferenceEngine _crossReferenceEngine;
    
    [HttpGet]
    public async Task<ActionResult<IEnumerable<DeckDto>>> GetDecks(
        [FromQuery] string? category = null,
        [FromQuery] string? subcategory = null)
    {
        var decks = string.IsNullOrEmpty(category) 
            ? await _deckRepository.GetAllAsync()
            : await _deckRepository.GetByCategoryAsync(category, subcategory);
            
        return Ok(decks.Select(DeckDto.FromDomain));
    }
    
    [HttpGet("{id}/cross-references")]
    public async Task<ActionResult<IEnumerable<CrossReferenceDto>>> GetCrossReferences(Guid id)
    {
        var references = await _crossReferenceEngine.FindRelatedContentAsync(id, "deck");
        return Ok(references.Select(CrossReferenceDto.FromDomain));
    }
}

// Retention.App/Controllers/GlossaryController.cs
[ApiController]
[Route("api/[controller]")]
public class GlossaryController : ControllerBase
{
    [HttpGet("search")]
    public async Task<ActionResult<IEnumerable<GlossaryTermDto>>> SearchTerms(
        [FromQuery] string query)
    {
        var terms = await _glossaryRepository.SearchTermsAsync(query);
        return Ok(terms.Select(GlossaryTermDto.FromDomain));
    }
    
    [HttpGet("flashcard/{flashcardId}")]
    public async Task<ActionResult<IEnumerable<GlossaryTermDto>>> GetTermsForFlashcard(Guid flashcardId)
    {
        var terms = await _glossaryRepository.GetForFlashcardAsync(flashcardId);
        return Ok(terms.Select(GlossaryTermDto.FromDomain));
    }
}
```

## Phase 7: Frontend Integration

### 7.1 Enhanced Fresh Islands

**Files to Create/Modify**:
- `Assessment/islands/EnhancedQuizInterface.tsx`
- `Assessment/islands/GlossaryPanel.tsx`
- `Assessment/islands/CrossReferencePanel.tsx`

```typescript
// Assessment/islands/EnhancedQuizInterface.tsx
interface EnhancedQuizInterfaceProps {
  flashcard: FlashcardWithMetadata;
  glossaryTerms: GlossaryTerm[];
  crossReferences: CrossReference[];
}

export default function EnhancedQuizInterface(props: EnhancedQuizInterfaceProps) {
  const [showGlossary, setShowGlossary] = useState(false);
  const [showReferences, setShowReferences] = useState(false);
  
  return (
    <div class="quiz-container">
      <div class="question-panel">
        {props.flashcard.metadata.type === 'scenario_based' && (
          <div class="scenario-panel">
            <h3>Scenario</h3>
            <p>{props.flashcard.metadata.scenario}</p>
          </div>
        )}
        
        <div class="question">
          <h2>{props.flashcard.question}</h2>
          
          {props.flashcard.metadata.type === 'multiple_choice' && (
            <div class="options">
              {props.flashcard.metadata.options.map((option, index) => (
                <label key={index}>
                  <input type="checkbox" value={option} />
                  {option}
                </label>
              ))}
            </div>
          )}
        </div>
      </div>
      
      <div class="sidebar">
        <button 
          onClick={() => setShowGlossary(!showGlossary)}
          class="sidebar-toggle"
        >
          üìö Glossary ({props.glossaryTerms.length})
        </button>
        
        <button 
          onClick={() => setShowReferences(!showReferences)}
          class="sidebar-toggle"
        >
          üîó References ({props.crossReferences.length})
        </button>
        
        {showGlossary && (
          <GlossaryPanel terms={props.glossaryTerms} />
        )}
        
        {showReferences && (
          <CrossReferencePanel references={props.crossReferences} />
        )}
      </div>
    </div>
  );
}
```

## Implementation Timeline

### ‚úÖ Week 1: Database Foundation - COMPLETED
- [x] Create PostgreSQL schema
- [x] Implement migration system (DbUp)
- [x] Set up database initialization

### ‚úÖ Week 2: Domain Model Enhancement - COMPLETED  
- [x] Expand domain entities (Deck, GlossaryTerm, CrossReference)
- [x] Create value objects for complex data (QuestionMetadata, SchedulingData)
- [x] Implement enhanced repositories (Deck, Glossary, CrossReference)

### ‚úÖ Week 3: Import System - COMPLETED
- [x] Build deck import service (138 decks, 11,644 flashcards)
- [x] Create glossary import functionality (530 terms)
- [x] Implement automatic cross-reference generation (foundation ready)

### ‚úÖ Week 4: Cross-Reference System - COMPLETED
- [x] Develop cross-reference repository and engine
- [x] Implement relationship detection via Master Index parsing
- [x] Create API endpoints for cross-references and backlinks

### ‚úÖ Week 5: API Enhancement - COMPLETED
- [x] Enhance existing controllers (Decks, Glossary)
- [x] Add new endpoints for glossary and cross-references
- [x] Implement search functionality (backend ready)

### ‚úÖ Week 6: Frontend Integration - COMPLETED
- [x] Create deck browser and detail pages
- [x] Build Obsidian-like network graph visualization (vis-network)
- [x] Implement responsive design with Tailwind CSS
- [x] Integrate deck selection with quiz system

### üîÑ Week 7: Testing & Optimization - IN PROGRESS
- [x] Basic functionality testing (frontend/backend communication)
- [ ] Unit tests for new functionality
- [ ] Integration tests for import system
- [ ] Performance optimization

### üìã Week 8: Deployment & Documentation - PENDING
- [ ] Production deployment
- [x] API documentation (Swagger available)
- [ ] User guides

## Questions for Clarification

1. **Database Hosting**: Are you planning to use a managed PostgreSQL service (AWS RDS, Azure Database, etc.) or self-hosted?

2. **Authentication**: Do you need user authentication and multi-user support, or is this single-user for now?

3. **Import Priority**: Which deck categories should we prioritize for the initial import (Healthcare, Sciences, etc.)?

4. **Cross-Reference Complexity**: How sophisticated should the automatic cross-reference detection be? Should it include semantic analysis or focus on keyword matching?

5. **Performance Requirements**: What are your expected concurrent user loads and response time requirements?

This plan provides a comprehensive roadmap for transforming AnkiQuiz into a sophisticated learning platform while maintaining the clean architecture and high-performance characteristics of your current Dapper + PostgreSQL implementation.
